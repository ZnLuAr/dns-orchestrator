//! MCP Server implementation for DNS Orchestrator
//!
//! Exposes 8 read-only tools for AI agents to interact with DNS management functionality.

use async_trait::async_trait;
use rmcp::{
    handler::server::{router::tool::ToolRouter, wrapper::Parameters},
    model::{
        CallToolResult, Content, Implementation, ProtocolVersion, ServerCapabilities, ServerInfo,
    },
    tool, tool_handler, tool_router, ErrorData as McpError, ServerHandler,
};
use std::sync::Arc;
use tokio::time::{timeout, Duration};

use dns_orchestrator_core::services::{
    AccountService, DnsService, DomainMetadataService, DomainService, ServiceContext,
};
use dns_orchestrator_core::types::DnsRecordType;
use dns_orchestrator_toolbox::{
    DnsLookupResult, DnsPropagationResult, DnssecResult, IpLookupResult, ToolboxError,
    ToolboxResult, ToolboxService, WhoisResult,
};

use crate::schemas::{
    DnsLookupParams, DnsPropagationCheckParams, DnssecCheckParams, IpLookupParams,
    ListAccountsParams, ListDomainsParams, ListRecordsParams, WhoisLookupParams,
};

// Timeout constants for external service calls
const DNS_LOOKUP_TIMEOUT_SECS: u64 = 30;
const WHOIS_LOOKUP_TIMEOUT_SECS: u64 = 30;
const IP_LOOKUP_TIMEOUT_SECS: u64 = 15;
const DNS_PROPAGATION_TIMEOUT_SECS: u64 = 60;
const DNSSEC_CHECK_TIMEOUT_SECS: u64 = 30;

#[derive(Clone, Copy)]
struct ToolTimeouts {
    dns_lookup: Duration,
    whois_lookup: Duration,
    ip_lookup: Duration,
    dns_propagation_check: Duration,
    dnssec_check: Duration,
}

impl Default for ToolTimeouts {
    fn default() -> Self {
        Self {
            dns_lookup: Duration::from_secs(DNS_LOOKUP_TIMEOUT_SECS),
            whois_lookup: Duration::from_secs(WHOIS_LOOKUP_TIMEOUT_SECS),
            ip_lookup: Duration::from_secs(IP_LOOKUP_TIMEOUT_SECS),
            dns_propagation_check: Duration::from_secs(DNS_PROPAGATION_TIMEOUT_SECS),
            dnssec_check: Duration::from_secs(DNSSEC_CHECK_TIMEOUT_SECS),
        }
    }
}

#[async_trait]
trait ToolboxGateway: Send + Sync {
    async fn dns_lookup(
        &self,
        domain: &str,
        record_type: &str,
        nameserver: Option<&str>,
    ) -> ToolboxResult<DnsLookupResult>;

    async fn whois_lookup(&self, domain: &str) -> ToolboxResult<WhoisResult>;

    async fn ip_lookup(&self, query: &str) -> ToolboxResult<IpLookupResult>;

    async fn dns_propagation_check(
        &self,
        domain: &str,
        record_type: &str,
    ) -> ToolboxResult<DnsPropagationResult>;

    async fn dnssec_check(
        &self,
        domain: &str,
        nameserver: Option<&str>,
    ) -> ToolboxResult<DnssecResult>;
}

#[derive(Default)]
struct DefaultToolboxGateway;

#[async_trait]
impl ToolboxGateway for DefaultToolboxGateway {
    async fn dns_lookup(
        &self,
        domain: &str,
        record_type: &str,
        nameserver: Option<&str>,
    ) -> ToolboxResult<DnsLookupResult> {
        ToolboxService::dns_lookup(domain, record_type, nameserver).await
    }

    async fn whois_lookup(&self, domain: &str) -> ToolboxResult<WhoisResult> {
        ToolboxService::whois_lookup(domain).await
    }

    async fn ip_lookup(&self, query: &str) -> ToolboxResult<IpLookupResult> {
        ToolboxService::ip_lookup(query).await
    }

    async fn dns_propagation_check(
        &self,
        domain: &str,
        record_type: &str,
    ) -> ToolboxResult<DnsPropagationResult> {
        ToolboxService::dns_propagation_check(domain, record_type).await
    }

    async fn dnssec_check(
        &self,
        domain: &str,
        nameserver: Option<&str>,
    ) -> ToolboxResult<DnssecResult> {
        ToolboxService::dnssec_check(domain, nameserver).await
    }
}

/// Sanitize error messages to prevent sensitive information leakage.
///
/// Logs the full error to stderr but returns a generic message to the client.
fn sanitize_internal_error(error: impl std::fmt::Display, context: &str) -> McpError {
    tracing::error!("{} error: {}", context, error);
    McpError::internal_error(
        format!("{context} failed - check server logs for details"),
        None,
    )
}

fn map_toolbox_error(context: &str, error: ToolboxError) -> McpError {
    tracing::warn!("{} error: {}", context, error);
    McpError::internal_error(error.to_string(), None)
}

/// MCP Server for DNS Orchestrator.
///
/// Provides AI agents with read-only access to DNS management functionality
/// through the Model Context Protocol.
#[derive(Clone)]
pub struct DnsOrchestratorMcp {
    /// Account service for account operations.
    account_service: Arc<AccountService>,
    /// Domain service for domain operations.
    domain_service: Arc<DomainService>,
    /// DNS service for record operations.
    dns_service: Arc<DnsService>,
    /// Toolbox gateway for network utilities.
    toolbox: Arc<dyn ToolboxGateway>,
    /// Timeout configuration for toolbox calls.
    timeouts: ToolTimeouts,
    /// Tool router generated by macro.
    tool_router: ToolRouter<Self>,
}

impl DnsOrchestratorMcp {
    /// Create a new MCP server instance.
    #[must_use]
    pub fn new(
        ctx: &Arc<ServiceContext>,
        account_service: Arc<AccountService>,
        domain_metadata_service: Arc<DomainMetadataService>,
    ) -> Self {
        Self::with_toolbox_and_timeouts(
            ctx,
            account_service,
            domain_metadata_service,
            Arc::new(DefaultToolboxGateway),
            ToolTimeouts::default(),
        )
    }

    fn with_toolbox_and_timeouts(
        ctx: &Arc<ServiceContext>,
        account_service: Arc<AccountService>,
        domain_metadata_service: Arc<DomainMetadataService>,
        toolbox: Arc<dyn ToolboxGateway>,
        timeouts: ToolTimeouts,
    ) -> Self {
        let domain_service = Arc::new(DomainService::new(Arc::clone(ctx), domain_metadata_service));
        let dns_service = Arc::new(DnsService::new(Arc::clone(ctx)));

        Self {
            account_service,
            domain_service,
            dns_service,
            toolbox,
            timeouts,
            tool_router: Self::tool_router(),
        }
    }
}

#[tool_router]
impl DnsOrchestratorMcp {
    /// List all configured DNS accounts.
    #[tool(
        description = "List all configured DNS provider accounts (Cloudflare, Aliyun, DNSPod, Huaweicloud)"
    )]
    async fn list_accounts(
        &self,
        _params: Parameters<ListAccountsParams>,
    ) -> Result<CallToolResult, McpError> {
        let accounts = self
            .account_service
            .list_accounts()
            .await
            .map_err(|e| sanitize_internal_error(e, "List accounts"))?;

        let json = serde_json::to_string_pretty(&accounts)
            .map_err(|e| sanitize_internal_error(e, "Serialize accounts"))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// List domains for a specific account.
    #[tool(description = "List all DNS domains for a specific account with pagination support")]
    async fn list_domains(
        &self,
        Parameters(params): Parameters<ListDomainsParams>,
    ) -> Result<CallToolResult, McpError> {
        // Limit page_size to prevent resource exhaustion
        let page_size = params.page_size.map(|s| s.min(100));

        let result = self
            .domain_service
            .list_domains(&params.account_id, params.page, page_size)
            .await
            .map_err(|e| sanitize_internal_error(e, "List domains"))?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| sanitize_internal_error(e, "Serialize domains"))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// List DNS records for a specific domain.
    #[tool(
        description = "List DNS records for a specific domain with pagination and filtering support"
    )]
    async fn list_records(
        &self,
        Parameters(params): Parameters<ListRecordsParams>,
    ) -> Result<CallToolResult, McpError> {
        let record_type = params
            .record_type
            .and_then(|t| match t.to_uppercase().as_str() {
                "A" => Some(DnsRecordType::A),
                "AAAA" => Some(DnsRecordType::Aaaa),
                "CNAME" => Some(DnsRecordType::Cname),
                "MX" => Some(DnsRecordType::Mx),
                "TXT" => Some(DnsRecordType::Txt),
                "NS" => Some(DnsRecordType::Ns),
                "SRV" => Some(DnsRecordType::Srv),
                "CAA" => Some(DnsRecordType::Caa),
                _ => None,
            });

        // Limit page_size to prevent resource exhaustion
        let page_size = params.page_size.map(|s| s.min(100));

        let result = self
            .dns_service
            .list_records(
                &params.account_id,
                &params.domain_id,
                params.page,
                page_size,
                params.keyword,
                record_type,
            )
            .await
            .map_err(|e| sanitize_internal_error(e, "List records"))?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| sanitize_internal_error(e, "Serialize records"))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// Perform DNS lookup.
    #[tool(
        description = "Perform DNS lookup for a domain (A, AAAA, CNAME, MX, TXT, NS, SOA, SRV, CAA, PTR, ALL)"
    )]
    async fn dns_lookup(
        &self,
        Parameters(params): Parameters<DnsLookupParams>,
    ) -> Result<CallToolResult, McpError> {
        let result = timeout(
            self.timeouts.dns_lookup,
            self.toolbox.dns_lookup(
                &params.domain,
                &params.record_type,
                params.nameserver.as_deref(),
            ),
        )
        .await
        .map_err(|_| McpError::internal_error("DNS lookup timeout".to_string(), None))?
        .map_err(|e| map_toolbox_error("DNS lookup", e))?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| sanitize_internal_error(e, "Serialize DNS lookup result"))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// Perform WHOIS lookup.
    #[tool(
        description = "Query WHOIS information for a domain (registrar, registration dates, name servers)"
    )]
    async fn whois_lookup(
        &self,
        Parameters(params): Parameters<WhoisLookupParams>,
    ) -> Result<CallToolResult, McpError> {
        let result = timeout(
            self.timeouts.whois_lookup,
            self.toolbox.whois_lookup(&params.domain),
        )
        .await
        .map_err(|_| McpError::internal_error("WHOIS lookup timeout".to_string(), None))?
        .map_err(|e| map_toolbox_error("WHOIS lookup", e))?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| sanitize_internal_error(e, "Serialize WHOIS result"))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// Perform IP geolocation lookup.
    #[tool(
        description = "Look up geolocation data for an IP address or domain (country, region, city, ISP, ASN)"
    )]
    async fn ip_lookup(
        &self,
        Parameters(params): Parameters<IpLookupParams>,
    ) -> Result<CallToolResult, McpError> {
        let result = timeout(
            self.timeouts.ip_lookup,
            self.toolbox.ip_lookup(&params.query),
        )
        .await
        .map_err(|_| McpError::internal_error("IP lookup timeout".to_string(), None))?
        .map_err(|e| map_toolbox_error("IP lookup", e))?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| sanitize_internal_error(e, "Serialize IP lookup result"))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// Check DNS propagation.
    #[tool(description = "Check DNS record propagation across 13 global DNS servers")]
    async fn dns_propagation_check(
        &self,
        Parameters(params): Parameters<DnsPropagationCheckParams>,
    ) -> Result<CallToolResult, McpError> {
        let result = timeout(
            self.timeouts.dns_propagation_check,
            self.toolbox
                .dns_propagation_check(&params.domain, &params.record_type),
        )
        .await
        .map_err(|_| McpError::internal_error("DNS propagation check timeout".to_string(), None))?
        .map_err(|e| map_toolbox_error("DNS propagation check", e))?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| sanitize_internal_error(e, "Serialize DNS propagation result"))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// Check DNSSEC status.
    #[tool(description = "Validate DNSSEC deployment for a domain (DNSKEY, DS, RRSIG records)")]
    async fn dnssec_check(
        &self,
        Parameters(params): Parameters<DnssecCheckParams>,
    ) -> Result<CallToolResult, McpError> {
        let result = timeout(
            self.timeouts.dnssec_check,
            self.toolbox
                .dnssec_check(&params.domain, params.nameserver.as_deref()),
        )
        .await
        .map_err(|_| McpError::internal_error("DNSSEC check timeout".to_string(), None))?
        .map_err(|e| map_toolbox_error("DNSSEC check", e))?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| sanitize_internal_error(e, "Serialize DNSSEC result"))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }
}

#[tool_handler]
impl ServerHandler for DnsOrchestratorMcp {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            protocol_version: ProtocolVersion::LATEST,
            capabilities: ServerCapabilities::builder().enable_tools().build(),
            server_info: Implementation::from_build_env(),
            instructions: Some(
                "DNS Orchestrator MCP Server - Read-only access to DNS accounts and records across multiple providers \
                 (Cloudflare, Aliyun, DNSPod, Huaweicloud). \
                 To modify DNS records, the user must manually open the DNS Orchestrator desktop application. \
                 Use list_accounts to see available accounts, list_domains to see domains, \
                 and list_records to view DNS records. \
                 Network diagnostic tools (dns_lookup, whois_lookup, ip_lookup, dns_propagation_check, dnssec_check) \
                 work without any account configuration."
                    .into(),
            ),
        }
    }
}

#[cfg(test)]
#[allow(clippy::unwrap_used, clippy::panic)]
mod tests {
    use super::*;

    use std::collections::HashMap;

    use dns_orchestrator_core::error::{CoreError, CoreResult};
    use dns_orchestrator_core::traits::{
        AccountRepository, CredentialStore, CredentialsMap, DomainMetadataRepository,
        InMemoryProviderRegistry, ProviderRegistry,
    };
    use dns_orchestrator_core::types::{
        Account, AccountStatus, DnsRecord, DnsRecordType as ProviderDnsRecordType, DomainStatus,
        PaginatedResponse, PaginationParams, ProviderCredentials, ProviderDomain, ProviderType,
        RecordData, RecordQueryParams,
    };
    use dns_orchestrator_provider::{
        CreateDnsRecordRequest, DnsProvider, ProviderError, ProviderFeatures, ProviderLimits,
        ProviderMetadata, UpdateDnsRecordRequest,
    };
    use tokio::sync::{Mutex, RwLock};

    use crate::adapters::NoOpDomainMetadataRepository;

    struct TestCredentialStore;

    #[async_trait]
    impl CredentialStore for TestCredentialStore {
        async fn load_all(&self) -> CoreResult<CredentialsMap> {
            Ok(HashMap::new())
        }

        async fn save_all(&self, _credentials: &CredentialsMap) -> CoreResult<()> {
            Ok(())
        }

        async fn get(&self, _account_id: &str) -> CoreResult<Option<ProviderCredentials>> {
            Ok(None)
        }

        async fn set(
            &self,
            _account_id: &str,
            _credentials: &ProviderCredentials,
        ) -> CoreResult<()> {
            Ok(())
        }

        async fn remove(&self, _account_id: &str) -> CoreResult<()> {
            Ok(())
        }

        async fn load_raw_json(&self) -> CoreResult<String> {
            Ok("{}".to_string())
        }

        async fn save_raw_json(&self, _json: &str) -> CoreResult<()> {
            Ok(())
        }
    }

    struct TestAccountRepository {
        accounts: RwLock<Vec<Account>>,
        fail_find_all: bool,
    }

    impl TestAccountRepository {
        fn new(accounts: Vec<Account>) -> Self {
            Self {
                accounts: RwLock::new(accounts),
                fail_find_all: false,
            }
        }

        fn failing_find_all() -> Self {
            Self {
                accounts: RwLock::new(Vec::new()),
                fail_find_all: true,
            }
        }
    }

    #[async_trait]
    impl AccountRepository for TestAccountRepository {
        async fn find_all(&self) -> CoreResult<Vec<Account>> {
            if self.fail_find_all {
                return Err(CoreError::StorageError("mock find_all failure".to_string()));
            }
            Ok(self.accounts.read().await.clone())
        }

        async fn find_by_id(&self, id: &str) -> CoreResult<Option<Account>> {
            Ok(self
                .accounts
                .read()
                .await
                .iter()
                .find(|account| account.id == id)
                .cloned())
        }

        async fn save(&self, account: &Account) -> CoreResult<()> {
            let mut accounts = self.accounts.write().await;
            if let Some(existing) = accounts.iter_mut().find(|item| item.id == account.id) {
                *existing = account.clone();
            } else {
                accounts.push(account.clone());
            }
            Ok(())
        }

        async fn delete(&self, id: &str) -> CoreResult<()> {
            let mut accounts = self.accounts.write().await;
            accounts.retain(|account| account.id != id);
            Ok(())
        }

        async fn save_all(&self, accounts: &[Account]) -> CoreResult<()> {
            *self.accounts.write().await = accounts.to_vec();
            Ok(())
        }

        async fn update_status(
            &self,
            id: &str,
            status: AccountStatus,
            error: Option<String>,
        ) -> CoreResult<()> {
            let mut accounts = self.accounts.write().await;
            let Some(account) = accounts.iter_mut().find(|item| item.id == id) else {
                return Err(CoreError::AccountNotFound(id.to_string()));
            };

            account.status = Some(status);
            account.error = error;
            account.updated_at = chrono::Utc::now();
            Ok(())
        }
    }

    #[derive(Default)]
    struct MockDnsProvider {
        last_domain_params: Mutex<Option<PaginationParams>>,
        last_records_domain_id: Mutex<Option<String>>,
        last_record_params: Mutex<Option<RecordQueryParams>>,
    }

    impl MockDnsProvider {
        async fn last_domain_params(&self) -> Option<PaginationParams> {
            self.last_domain_params.lock().await.clone()
        }

        async fn last_records_domain_id(&self) -> Option<String> {
            self.last_records_domain_id.lock().await.clone()
        }

        async fn last_record_params(&self) -> Option<RecordQueryParams> {
            self.last_record_params.lock().await.clone()
        }
    }

    #[async_trait]
    impl DnsProvider for MockDnsProvider {
        fn id(&self) -> &'static str {
            "mock"
        }

        fn metadata() -> ProviderMetadata {
            ProviderMetadata {
                id: ProviderType::Cloudflare,
                name: "Mock Provider".to_string(),
                description: "Test provider".to_string(),
                required_fields: Vec::new(),
                features: ProviderFeatures::default(),
                limits: ProviderLimits {
                    max_page_size_domains: 100,
                    max_page_size_records: 100,
                },
            }
        }

        async fn validate_credentials(&self) -> dns_orchestrator_provider::Result<bool> {
            Ok(true)
        }

        async fn list_domains(
            &self,
            params: &PaginationParams,
        ) -> dns_orchestrator_provider::Result<PaginatedResponse<ProviderDomain>> {
            *self.last_domain_params.lock().await = Some(params.clone());

            Ok(PaginatedResponse::new(
                vec![ProviderDomain {
                    id: "dom-1".to_string(),
                    name: "example.com".to_string(),
                    provider: ProviderType::Cloudflare,
                    status: DomainStatus::Active,
                    record_count: Some(1),
                }],
                params.page,
                params.page_size,
                1,
            ))
        }

        async fn get_domain(
            &self,
            domain_id: &str,
        ) -> dns_orchestrator_provider::Result<ProviderDomain> {
            Ok(ProviderDomain {
                id: domain_id.to_string(),
                name: "example.com".to_string(),
                provider: ProviderType::Cloudflare,
                status: DomainStatus::Active,
                record_count: Some(1),
            })
        }

        async fn list_records(
            &self,
            domain_id: &str,
            params: &RecordQueryParams,
        ) -> dns_orchestrator_provider::Result<PaginatedResponse<DnsRecord>> {
            *self.last_records_domain_id.lock().await = Some(domain_id.to_string());
            *self.last_record_params.lock().await = Some(params.clone());

            Ok(PaginatedResponse::new(
                vec![DnsRecord {
                    id: "rec-1".to_string(),
                    domain_id: domain_id.to_string(),
                    name: "www".to_string(),
                    ttl: 300,
                    data: RecordData::A {
                        address: "1.1.1.1".to_string(),
                    },
                    proxied: None,
                    created_at: None,
                    updated_at: None,
                }],
                params.page,
                params.page_size,
                1,
            ))
        }

        async fn create_record(
            &self,
            _req: &CreateDnsRecordRequest,
        ) -> dns_orchestrator_provider::Result<DnsRecord> {
            Err(ProviderError::Unknown {
                provider: "mock".to_string(),
                raw_code: None,
                raw_message: "not implemented".to_string(),
            })
        }

        async fn update_record(
            &self,
            _record_id: &str,
            _req: &UpdateDnsRecordRequest,
        ) -> dns_orchestrator_provider::Result<DnsRecord> {
            Err(ProviderError::Unknown {
                provider: "mock".to_string(),
                raw_code: None,
                raw_message: "not implemented".to_string(),
            })
        }

        async fn delete_record(
            &self,
            _record_id: &str,
            _domain_id: &str,
        ) -> dns_orchestrator_provider::Result<()> {
            Err(ProviderError::Unknown {
                provider: "mock".to_string(),
                raw_code: None,
                raw_message: "not implemented".to_string(),
            })
        }
    }

    #[derive(Default)]
    struct MockToolboxGateway {
        dns_lookup_calls: Mutex<Vec<(String, String, Option<String>)>>,
        dns_lookup_delay: Mutex<Option<Duration>>,
        dns_lookup_error: Mutex<Option<String>>,
        whois_calls: Mutex<Vec<String>>,
        ip_calls: Mutex<Vec<String>>,
        propagation_calls: Mutex<Vec<(String, String)>>,
        dnssec_calls: Mutex<Vec<(String, Option<String>)>>,
    }

    impl MockToolboxGateway {
        async fn set_dns_lookup_delay(&self, delay: Option<Duration>) {
            *self.dns_lookup_delay.lock().await = delay;
        }

        async fn set_dns_lookup_error(&self, error: Option<String>) {
            *self.dns_lookup_error.lock().await = error;
        }

        async fn dns_lookup_calls(&self) -> Vec<(String, String, Option<String>)> {
            self.dns_lookup_calls.lock().await.clone()
        }

        async fn whois_calls(&self) -> Vec<String> {
            self.whois_calls.lock().await.clone()
        }

        async fn ip_calls(&self) -> Vec<String> {
            self.ip_calls.lock().await.clone()
        }

        async fn propagation_calls(&self) -> Vec<(String, String)> {
            self.propagation_calls.lock().await.clone()
        }

        async fn dnssec_calls(&self) -> Vec<(String, Option<String>)> {
            self.dnssec_calls.lock().await.clone()
        }
    }

    #[async_trait]
    impl ToolboxGateway for MockToolboxGateway {
        async fn dns_lookup(
            &self,
            domain: &str,
            record_type: &str,
            nameserver: Option<&str>,
        ) -> ToolboxResult<DnsLookupResult> {
            self.dns_lookup_calls.lock().await.push((
                domain.to_string(),
                record_type.to_string(),
                nameserver.map(std::string::ToString::to_string),
            ));

            if let Some(delay) = *self.dns_lookup_delay.lock().await {
                tokio::time::sleep(delay).await;
            }

            if let Some(message) = self.dns_lookup_error.lock().await.clone() {
                return Err(ToolboxError::NetworkError(message));
            }

            Ok(DnsLookupResult {
                nameserver: nameserver.unwrap_or("system").to_string(),
                records: vec![dns_record()],
            })
        }

        async fn whois_lookup(&self, domain: &str) -> ToolboxResult<WhoisResult> {
            self.whois_calls.lock().await.push(domain.to_string());
            Ok(WhoisResult {
                domain: domain.to_string(),
                registrar: Some("Mock Registrar".to_string()),
                creation_date: None,
                expiration_date: None,
                updated_date: None,
                name_servers: vec!["ns1.example.com".to_string()],
                status: vec!["active".to_string()],
                raw: "mock-raw".to_string(),
            })
        }

        async fn ip_lookup(&self, query: &str) -> ToolboxResult<IpLookupResult> {
            self.ip_calls.lock().await.push(query.to_string());
            Ok(IpLookupResult {
                query: query.to_string(),
                is_domain: false,
                results: vec![dns_orchestrator_toolbox::IpGeoInfo {
                    ip: "1.1.1.1".to_string(),
                    ip_version: "IPv4".to_string(),
                    country: Some("US".to_string()),
                    country_code: Some("US".to_string()),
                    region: None,
                    city: None,
                    latitude: None,
                    longitude: None,
                    timezone: None,
                    isp: None,
                    org: None,
                    asn: None,
                    as_name: None,
                }],
            })
        }

        async fn dns_propagation_check(
            &self,
            domain: &str,
            record_type: &str,
        ) -> ToolboxResult<DnsPropagationResult> {
            self.propagation_calls
                .lock()
                .await
                .push((domain.to_string(), record_type.to_string()));
            Ok(DnsPropagationResult {
                domain: domain.to_string(),
                record_type: record_type.to_string(),
                results: vec![dns_orchestrator_toolbox::DnsPropagationServerResult {
                    server: dns_orchestrator_toolbox::DnsPropagationServer {
                        name: "Mock DNS".to_string(),
                        ip: "1.1.1.1".to_string(),
                        region: "NA".to_string(),
                        country_code: "US".to_string(),
                    },
                    status: dns_orchestrator_toolbox::PropagationStatus::Success,
                    records: vec![dns_record()],
                    error: None,
                    response_time_ms: 10,
                }],
                total_time_ms: 10,
                consistency_percentage: 100.0,
                unique_values: vec!["1.1.1.1".to_string()],
            })
        }

        async fn dnssec_check(
            &self,
            domain: &str,
            nameserver: Option<&str>,
        ) -> ToolboxResult<DnssecResult> {
            self.dnssec_calls.lock().await.push((
                domain.to_string(),
                nameserver.map(std::string::ToString::to_string),
            ));
            Ok(DnssecResult {
                domain: domain.to_string(),
                dnssec_enabled: false,
                dnskey_records: Vec::new(),
                ds_records: Vec::new(),
                rrsig_records: Vec::new(),
                validation_status: dns_orchestrator_toolbox::DnssecValidationStatus::Insecure,
                nameserver: nameserver.unwrap_or("system").to_string(),
                response_time_ms: 10,
                error: None,
            })
        }
    }

    fn dns_record() -> dns_orchestrator_toolbox::DnsLookupRecord {
        dns_orchestrator_toolbox::DnsLookupRecord {
            record_type: "A".to_string(),
            name: "example.com".to_string(),
            value: "1.1.1.1".to_string(),
            ttl: 300,
            priority: None,
        }
    }

    fn test_account(account_id: &str) -> Account {
        Account {
            id: account_id.to_string(),
            name: "Test Account".to_string(),
            provider: ProviderType::Cloudflare,
            created_at: chrono::Utc::now(),
            updated_at: chrono::Utc::now(),
            status: Some(AccountStatus::Active),
            error: None,
        }
    }

    async fn build_server(
        account_repository: Arc<dyn AccountRepository>,
        provider: Option<Arc<MockDnsProvider>>,
        toolbox: Arc<dyn ToolboxGateway>,
        timeouts: ToolTimeouts,
    ) -> DnsOrchestratorMcp {
        let credential_store: Arc<dyn CredentialStore> = Arc::new(TestCredentialStore);
        let provider_registry = Arc::new(InMemoryProviderRegistry::new());

        if let Some(mock_provider) = provider {
            provider_registry
                .register("acc-1".to_string(), mock_provider)
                .await;
        }

        let domain_metadata_repository: Arc<dyn DomainMetadataRepository> =
            Arc::new(NoOpDomainMetadataRepository::new());

        let ctx = Arc::new(ServiceContext::new(
            credential_store,
            account_repository,
            provider_registry,
            Arc::clone(&domain_metadata_repository),
        ));

        let account_service = Arc::new(AccountService::new(Arc::clone(&ctx)));
        let domain_metadata_service =
            Arc::new(DomainMetadataService::new(domain_metadata_repository));

        DnsOrchestratorMcp::with_toolbox_and_timeouts(
            &ctx,
            account_service,
            domain_metadata_service,
            toolbox,
            timeouts,
        )
    }

    #[test]
    fn sanitize_internal_error_hides_error_details() {
        let error = sanitize_internal_error("sensitive: token=123", "List accounts");
        let message = error.to_string();
        assert!(message.contains("List accounts failed"));
        assert!(!message.contains("token=123"));
    }

    #[tokio::test]
    async fn list_accounts_returns_success() {
        let account_repository: Arc<dyn AccountRepository> =
            Arc::new(TestAccountRepository::new(vec![test_account("acc-1")]));
        let toolbox = Arc::new(MockToolboxGateway::default());

        let server = build_server(account_repository, None, toolbox, ToolTimeouts::default()).await;

        let result = server
            .list_accounts(Parameters(ListAccountsParams {}))
            .await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn list_accounts_error_is_sanitized() {
        let account_repository: Arc<dyn AccountRepository> =
            Arc::new(TestAccountRepository::failing_find_all());
        let toolbox = Arc::new(MockToolboxGateway::default());

        let server = build_server(account_repository, None, toolbox, ToolTimeouts::default()).await;

        let error = server
            .list_accounts(Parameters(ListAccountsParams {}))
            .await
            .unwrap_err();

        let message = error.to_string();
        assert!(message.contains("List accounts failed"));
        assert!(!message.contains("mock find_all failure"));
    }

    #[tokio::test]
    async fn list_domains_clamps_page_size() {
        let account_repository: Arc<dyn AccountRepository> =
            Arc::new(TestAccountRepository::new(vec![test_account("acc-1")]));
        let provider = Arc::new(MockDnsProvider::default());
        let toolbox = Arc::new(MockToolboxGateway::default());

        let server = build_server(
            account_repository,
            Some(Arc::clone(&provider)),
            toolbox,
            ToolTimeouts::default(),
        )
        .await;

        let result = server
            .list_domains(Parameters(ListDomainsParams {
                account_id: "acc-1".to_string(),
                page: Some(2),
                page_size: Some(999),
            }))
            .await;

        assert!(result.is_ok());

        let params = provider.last_domain_params().await.unwrap();
        assert_eq!(params.page, 2);
        assert_eq!(params.page_size, 100);
    }

    #[tokio::test]
    async fn list_records_maps_type_and_clamps_page_size() {
        let account_repository: Arc<dyn AccountRepository> =
            Arc::new(TestAccountRepository::new(vec![test_account("acc-1")]));
        let provider = Arc::new(MockDnsProvider::default());
        let toolbox = Arc::new(MockToolboxGateway::default());

        let server = build_server(
            account_repository,
            Some(Arc::clone(&provider)),
            toolbox,
            ToolTimeouts::default(),
        )
        .await;

        let result = server
            .list_records(Parameters(ListRecordsParams {
                account_id: "acc-1".to_string(),
                domain_id: "dom-1".to_string(),
                page: Some(1),
                page_size: Some(500),
                keyword: Some("www".to_string()),
                record_type: Some("mx".to_string()),
            }))
            .await;

        assert!(result.is_ok());
        assert_eq!(
            provider.last_records_domain_id().await,
            Some("dom-1".to_string())
        );

        let params = provider.last_record_params().await.unwrap();
        assert_eq!(params.page_size, 100);
        assert_eq!(params.keyword, Some("www".to_string()));
        assert_eq!(params.record_type, Some(ProviderDnsRecordType::Mx));
    }

    #[tokio::test]
    async fn list_records_unknown_type_becomes_none() {
        let account_repository: Arc<dyn AccountRepository> =
            Arc::new(TestAccountRepository::new(vec![test_account("acc-1")]));
        let provider = Arc::new(MockDnsProvider::default());
        let toolbox = Arc::new(MockToolboxGateway::default());

        let server = build_server(
            account_repository,
            Some(Arc::clone(&provider)),
            toolbox,
            ToolTimeouts::default(),
        )
        .await;

        let result = server
            .list_records(Parameters(ListRecordsParams {
                account_id: "acc-1".to_string(),
                domain_id: "dom-1".to_string(),
                page: Some(1),
                page_size: Some(20),
                keyword: None,
                record_type: Some("UNKNOWN".to_string()),
            }))
            .await;

        assert!(result.is_ok());

        let params = provider.last_record_params().await.unwrap();
        assert!(params.record_type.is_none());
    }

    #[tokio::test]
    async fn dns_lookup_uses_toolbox_arguments() {
        let account_repository: Arc<dyn AccountRepository> =
            Arc::new(TestAccountRepository::new(Vec::new()));
        let toolbox = Arc::new(MockToolboxGateway::default());

        let server = build_server(
            account_repository,
            None,
            Arc::clone(&toolbox) as Arc<dyn ToolboxGateway>,
            ToolTimeouts::default(),
        )
        .await;

        let result = server
            .dns_lookup(Parameters(DnsLookupParams {
                domain: "example.com".to_string(),
                record_type: "A".to_string(),
                nameserver: Some("8.8.8.8".to_string()),
            }))
            .await;

        assert!(result.is_ok());

        let calls = toolbox.dns_lookup_calls().await;
        assert_eq!(calls.len(), 1);
        assert_eq!(calls[0].0, "example.com");
        assert_eq!(calls[0].1, "A");
        assert_eq!(calls[0].2, Some("8.8.8.8".to_string()));
    }

    #[tokio::test]
    async fn dns_lookup_returns_toolbox_error_message() {
        let account_repository: Arc<dyn AccountRepository> =
            Arc::new(TestAccountRepository::new(Vec::new()));
        let toolbox = Arc::new(MockToolboxGateway::default());
        toolbox
            .set_dns_lookup_error(Some("mock dns lookup failed".to_string()))
            .await;

        let server = build_server(
            account_repository,
            None,
            Arc::clone(&toolbox) as Arc<dyn ToolboxGateway>,
            ToolTimeouts::default(),
        )
        .await;

        let error = server
            .dns_lookup(Parameters(DnsLookupParams {
                domain: "example.com".to_string(),
                record_type: "A".to_string(),
                nameserver: None,
            }))
            .await
            .unwrap_err();

        assert!(error.to_string().contains("mock dns lookup failed"));
    }

    #[tokio::test]
    async fn dns_lookup_timeout_returns_timeout_error() {
        let account_repository: Arc<dyn AccountRepository> =
            Arc::new(TestAccountRepository::new(Vec::new()));
        let toolbox = Arc::new(MockToolboxGateway::default());
        toolbox
            .set_dns_lookup_delay(Some(Duration::from_millis(50)))
            .await;

        let timeouts = ToolTimeouts {
            dns_lookup: Duration::from_millis(5),
            ..ToolTimeouts::default()
        };

        let server = build_server(
            account_repository,
            None,
            Arc::clone(&toolbox) as Arc<dyn ToolboxGateway>,
            timeouts,
        )
        .await;

        let error = server
            .dns_lookup(Parameters(DnsLookupParams {
                domain: "example.com".to_string(),
                record_type: "A".to_string(),
                nameserver: None,
            }))
            .await
            .unwrap_err();

        assert!(error.to_string().contains("DNS lookup timeout"));
    }

    #[tokio::test]
    async fn toolbox_tools_delegate_to_gateway() {
        let account_repository: Arc<dyn AccountRepository> =
            Arc::new(TestAccountRepository::new(Vec::new()));
        let toolbox = Arc::new(MockToolboxGateway::default());

        let server = build_server(
            account_repository,
            None,
            Arc::clone(&toolbox) as Arc<dyn ToolboxGateway>,
            ToolTimeouts::default(),
        )
        .await;

        assert!(server
            .whois_lookup(Parameters(WhoisLookupParams {
                domain: "example.com".to_string(),
            }))
            .await
            .is_ok());
        assert!(server
            .ip_lookup(Parameters(IpLookupParams {
                query: "1.1.1.1".to_string(),
            }))
            .await
            .is_ok());
        assert!(server
            .dns_propagation_check(Parameters(DnsPropagationCheckParams {
                domain: "example.com".to_string(),
                record_type: "A".to_string(),
            }))
            .await
            .is_ok());
        assert!(server
            .dnssec_check(Parameters(DnssecCheckParams {
                domain: "example.com".to_string(),
                nameserver: Some("8.8.8.8".to_string()),
            }))
            .await
            .is_ok());

        assert_eq!(toolbox.whois_calls().await, vec!["example.com".to_string()]);
        assert_eq!(toolbox.ip_calls().await, vec!["1.1.1.1".to_string()]);
        assert_eq!(
            toolbox.propagation_calls().await,
            vec![("example.com".to_string(), "A".to_string())]
        );
        assert_eq!(
            toolbox.dnssec_calls().await,
            vec![("example.com".to_string(), Some("8.8.8.8".to_string()))]
        );
    }

    #[tokio::test]
    async fn get_info_contains_expected_instructions() {
        let account_repository: Arc<dyn AccountRepository> =
            Arc::new(TestAccountRepository::new(Vec::new()));
        let toolbox = Arc::new(MockToolboxGateway::default());
        let server = build_server(account_repository, None, toolbox, ToolTimeouts::default()).await;

        let info = server.get_info();

        assert_eq!(info.protocol_version, ProtocolVersion::LATEST);
        let instructions = info.instructions.unwrap_or_default();
        assert!(instructions.contains("list_accounts"));
        assert!(instructions.contains("Toolbox tools"));
    }
}
