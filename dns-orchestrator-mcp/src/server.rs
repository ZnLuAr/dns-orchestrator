//! MCP Server implementation for DNS Orchestrator
//!
//! Exposes 8 read-only tools for AI agents to interact with DNS management functionality.

use rmcp::{
    handler::server::{router::tool::ToolRouter, wrapper::Parameters},
    model::{CallToolResult, Content, Implementation, ProtocolVersion, ServerCapabilities, ServerInfo},
    tool, tool_handler, tool_router,
    ErrorData as McpError, ServerHandler,
};
use std::sync::Arc;
use tokio::time::{timeout, Duration};

use dns_orchestrator_core::services::{AccountService, DnsService, DomainMetadataService, DomainService, ServiceContext};
use dns_orchestrator_core::types::DnsRecordType;
use dns_orchestrator_toolbox::ToolboxService;

use crate::schemas::{
    DnsLookupParams, DnsPropagationCheckParams, DnssecCheckParams, IpLookupParams,
    ListAccountsParams, ListDomainsParams, ListRecordsParams, WhoisLookupParams,
};

// Timeout constants for external service calls
const DNS_LOOKUP_TIMEOUT_SECS: u64 = 30;
const WHOIS_LOOKUP_TIMEOUT_SECS: u64 = 30;
const IP_LOOKUP_TIMEOUT_SECS: u64 = 15;
const DNS_PROPAGATION_TIMEOUT_SECS: u64 = 60;
const DNSSEC_CHECK_TIMEOUT_SECS: u64 = 30;

/// Sanitize error messages to prevent sensitive information leakage.
///
/// Logs the full error to stderr but returns a generic message to the client.
fn sanitize_internal_error(error: impl std::fmt::Display, context: &str) -> McpError {
    tracing::error!("{} error: {}", context, error);
    McpError::internal_error(
        format!("{} failed - check server logs for details", context),
        None,
    )
}

/// MCP Server for DNS Orchestrator.
///
/// Provides AI agents with read-only access to DNS management functionality
/// through the Model Context Protocol.
#[derive(Clone)]
pub struct DnsOrchestratorMcp {
    /// Account service for account operations.
    account_service: Arc<AccountService>,
    /// Domain service for domain operations.
    domain_service: Arc<DomainService>,
    /// DNS service for record operations.
    dns_service: Arc<DnsService>,
    /// Tool router generated by macro.
    tool_router: ToolRouter<Self>,
}

impl DnsOrchestratorMcp {
    /// Create a new MCP server instance.
    #[must_use]
    pub fn new(
        ctx: &Arc<ServiceContext>,
        account_service: Arc<AccountService>,
        domain_metadata_service: Arc<DomainMetadataService>,
    ) -> Self {
        let domain_service = Arc::new(DomainService::new(Arc::clone(ctx), domain_metadata_service));
        let dns_service = Arc::new(DnsService::new(Arc::clone(ctx)));

        Self {
            account_service,
            domain_service,
            dns_service,
            tool_router: Self::tool_router(),
        }
    }
}

#[tool_router]
impl DnsOrchestratorMcp {
    /// List all configured DNS accounts.
    #[tool(description = "List all configured DNS provider accounts (Cloudflare, Aliyun, DNSPod, Huaweicloud)")]
    async fn list_accounts(
        &self,
        _params: Parameters<ListAccountsParams>,
    ) -> Result<CallToolResult, McpError> {
        let accounts = self
            .account_service
            .list_accounts()
            .await
            .map_err(|e| sanitize_internal_error(e, "List accounts"))?;

        let json = serde_json::to_string_pretty(&accounts)
            .map_err(|e| sanitize_internal_error(e, "Serialize accounts"))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// List domains for a specific account.
    #[tool(description = "List all DNS domains for a specific account with pagination support")]
    async fn list_domains(
        &self,
        Parameters(params): Parameters<ListDomainsParams>,
    ) -> Result<CallToolResult, McpError> {
        // Limit page_size to prevent resource exhaustion
        let page_size = params.page_size.map(|s| s.min(100));

        let result = self
            .domain_service
            .list_domains(&params.account_id, params.page, page_size)
            .await
            .map_err(|e| sanitize_internal_error(e, "List domains"))?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| sanitize_internal_error(e, "Serialize domains"))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// List DNS records for a specific domain.
    #[tool(description = "List DNS records for a specific domain with pagination and filtering support")]
    async fn list_records(
        &self,
        Parameters(params): Parameters<ListRecordsParams>,
    ) -> Result<CallToolResult, McpError> {
        let record_type = params.record_type.and_then(|t| match t.to_uppercase().as_str() {
            "A" => Some(DnsRecordType::A),
            "AAAA" => Some(DnsRecordType::Aaaa),
            "CNAME" => Some(DnsRecordType::Cname),
            "MX" => Some(DnsRecordType::Mx),
            "TXT" => Some(DnsRecordType::Txt),
            "NS" => Some(DnsRecordType::Ns),
            "SRV" => Some(DnsRecordType::Srv),
            "CAA" => Some(DnsRecordType::Caa),
            _ => None,
        });

        // Limit page_size to prevent resource exhaustion
        let page_size = params.page_size.map(|s| s.min(100));

        let result = self
            .dns_service
            .list_records(
                &params.account_id,
                &params.domain_id,
                params.page,
                page_size,
                params.keyword,
                record_type,
            )
            .await
            .map_err(|e| sanitize_internal_error(e, "List records"))?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| sanitize_internal_error(e, "Serialize records"))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// Perform DNS lookup.
    #[tool(description = "Perform DNS lookup for a domain (A, AAAA, CNAME, MX, TXT, NS, SOA, SRV, CAA, PTR, ALL)")]
    async fn dns_lookup(
        &self,
        Parameters(params): Parameters<DnsLookupParams>,
    ) -> Result<CallToolResult, McpError> {
        let result = timeout(
            Duration::from_secs(DNS_LOOKUP_TIMEOUT_SECS),
            ToolboxService::dns_lookup(
                &params.domain,
                &params.record_type,
                params.nameserver.as_deref(),
            ),
        )
        .await
        .map_err(|_| McpError::internal_error("DNS lookup timeout".to_string(), None))?
        .map_err(|e| {
            tracing::warn!("DNS lookup error: {}", e);
            McpError::internal_error(e.to_string(), None)
        })?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| sanitize_internal_error(e, "Serialize DNS lookup result"))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// Perform WHOIS lookup.
    #[tool(description = "Query WHOIS information for a domain (registrar, registration dates, name servers)")]
    async fn whois_lookup(
        &self,
        Parameters(params): Parameters<WhoisLookupParams>,
    ) -> Result<CallToolResult, McpError> {
        let result = timeout(
            Duration::from_secs(WHOIS_LOOKUP_TIMEOUT_SECS),
            ToolboxService::whois_lookup(&params.domain),
        )
        .await
        .map_err(|_| McpError::internal_error("WHOIS lookup timeout".to_string(), None))?
        .map_err(|e| {
            tracing::warn!("WHOIS lookup error: {}", e);
            McpError::internal_error(e.to_string(), None)
        })?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| sanitize_internal_error(e, "Serialize WHOIS result"))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// Perform IP geolocation lookup.
    #[tool(description = "Look up geolocation data for an IP address or domain (country, region, city, ISP, ASN)")]
    async fn ip_lookup(
        &self,
        Parameters(params): Parameters<IpLookupParams>,
    ) -> Result<CallToolResult, McpError> {
        let result = timeout(
            Duration::from_secs(IP_LOOKUP_TIMEOUT_SECS),
            ToolboxService::ip_lookup(&params.query),
        )
        .await
        .map_err(|_| McpError::internal_error("IP lookup timeout".to_string(), None))?
        .map_err(|e| {
            tracing::warn!("IP lookup error: {}", e);
            McpError::internal_error(e.to_string(), None)
        })?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| sanitize_internal_error(e, "Serialize IP lookup result"))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// Check DNS propagation.
    #[tool(description = "Check DNS record propagation across 13 global DNS servers")]
    async fn dns_propagation_check(
        &self,
        Parameters(params): Parameters<DnsPropagationCheckParams>,
    ) -> Result<CallToolResult, McpError> {
        let result = timeout(
            Duration::from_secs(DNS_PROPAGATION_TIMEOUT_SECS),
            ToolboxService::dns_propagation_check(&params.domain, &params.record_type),
        )
        .await
        .map_err(|_| McpError::internal_error("DNS propagation check timeout".to_string(), None))?
        .map_err(|e| {
            tracing::warn!("DNS propagation check error: {}", e);
            McpError::internal_error(e.to_string(), None)
        })?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| sanitize_internal_error(e, "Serialize DNS propagation result"))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// Check DNSSEC status.
    #[tool(description = "Validate DNSSEC deployment for a domain (DNSKEY, DS, RRSIG records)")]
    async fn dnssec_check(
        &self,
        Parameters(params): Parameters<DnssecCheckParams>,
    ) -> Result<CallToolResult, McpError> {
        let result = timeout(
            Duration::from_secs(DNSSEC_CHECK_TIMEOUT_SECS),
            ToolboxService::dnssec_check(&params.domain, params.nameserver.as_deref()),
        )
        .await
        .map_err(|_| McpError::internal_error("DNSSEC check timeout".to_string(), None))?
        .map_err(|e| {
            tracing::warn!("DNSSEC check error: {}", e);
            McpError::internal_error(e.to_string(), None)
        })?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| sanitize_internal_error(e, "Serialize DNSSEC result"))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }
}

#[tool_handler]
impl ServerHandler for DnsOrchestratorMcp {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            protocol_version: ProtocolVersion::LATEST,
            capabilities: ServerCapabilities::builder().enable_tools().build(),
            server_info: Implementation::from_build_env(),
            instructions: Some(
                "DNS Orchestrator MCP Server - Manage DNS records across multiple providers \
                 (Cloudflare, Aliyun, DNSPod, Huaweicloud). \
                 Use list_accounts to see available accounts, list_domains to see domains, \
                 and list_records to view DNS records. \
                 Toolbox tools (dns_lookup, whois_lookup, ip_lookup, dns_propagation_check, dnssec_check) \
                 work without any account configuration."
                    .into(),
            ),
        }
    }
}
