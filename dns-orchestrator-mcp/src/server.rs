//! MCP Server implementation for DNS Orchestrator
//!
//! Exposes 8 read-only tools for AI agents to interact with DNS management functionality.

use rmcp::{
    handler::server::{router::tool::ToolRouter, wrapper::Parameters},
    model::{CallToolResult, Content, Implementation, ProtocolVersion, ServerCapabilities, ServerInfo},
    tool, tool_handler, tool_router,
    ErrorData as McpError, ServerHandler,
};
use std::sync::Arc;

use dns_orchestrator_core::services::{AccountService, DnsService, DomainMetadataService, DomainService, ServiceContext};
use dns_orchestrator_core::types::DnsRecordType;
use dns_orchestrator_toolbox::ToolboxService;

use crate::schemas::{
    DnsLookupParams, DnsPropagationCheckParams, DnssecCheckParams, IpLookupParams,
    ListAccountsParams, ListDomainsParams, ListRecordsParams, WhoisLookupParams,
};

/// MCP Server for DNS Orchestrator.
///
/// Provides AI agents with read-only access to DNS management functionality
/// through the Model Context Protocol.
#[derive(Clone)]
pub struct DnsOrchestratorMcp {
    /// Account service for account operations.
    account_service: Arc<AccountService>,
    /// Domain service for domain operations.
    domain_service: Arc<DomainService>,
    /// DNS service for record operations.
    dns_service: Arc<DnsService>,
    /// Tool router generated by macro.
    tool_router: ToolRouter<Self>,
}

impl DnsOrchestratorMcp {
    /// Create a new MCP server instance.
    #[must_use]
    pub fn new(
        ctx: &Arc<ServiceContext>,
        account_service: Arc<AccountService>,
        domain_metadata_service: Arc<DomainMetadataService>,
    ) -> Self {
        let domain_service = Arc::new(DomainService::new(Arc::clone(ctx), domain_metadata_service));
        let dns_service = Arc::new(DnsService::new(Arc::clone(ctx)));

        Self {
            account_service,
            domain_service,
            dns_service,
            tool_router: Self::tool_router(),
        }
    }
}

#[tool_router]
impl DnsOrchestratorMcp {
    /// List all configured DNS accounts.
    #[tool(description = "List all configured DNS provider accounts (Cloudflare, Aliyun, DNSPod, Huaweicloud)")]
    async fn list_accounts(
        &self,
        _params: Parameters<ListAccountsParams>,
    ) -> Result<CallToolResult, McpError> {
        let accounts = self
            .account_service
            .list_accounts()
            .await
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        let json = serde_json::to_string_pretty(&accounts)
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// List domains for a specific account.
    #[tool(description = "List all DNS domains for a specific account with pagination support")]
    async fn list_domains(
        &self,
        Parameters(params): Parameters<ListDomainsParams>,
    ) -> Result<CallToolResult, McpError> {
        let result = self
            .domain_service
            .list_domains(&params.account_id, params.page, params.page_size)
            .await
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// List DNS records for a specific domain.
    #[tool(description = "List DNS records for a specific domain with pagination and filtering support")]
    async fn list_records(
        &self,
        Parameters(params): Parameters<ListRecordsParams>,
    ) -> Result<CallToolResult, McpError> {
        let record_type = params.record_type.and_then(|t| match t.to_uppercase().as_str() {
            "A" => Some(DnsRecordType::A),
            "AAAA" => Some(DnsRecordType::Aaaa),
            "CNAME" => Some(DnsRecordType::Cname),
            "MX" => Some(DnsRecordType::Mx),
            "TXT" => Some(DnsRecordType::Txt),
            "NS" => Some(DnsRecordType::Ns),
            "SRV" => Some(DnsRecordType::Srv),
            "CAA" => Some(DnsRecordType::Caa),
            _ => None,
        });

        let result = self
            .dns_service
            .list_records(
                &params.account_id,
                &params.domain_id,
                params.page,
                params.page_size,
                params.keyword,
                record_type,
            )
            .await
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// Perform DNS lookup.
    #[tool(description = "Perform DNS lookup for a domain (A, AAAA, CNAME, MX, TXT, NS, SOA, SRV, CAA, PTR, ALL)")]
    async fn dns_lookup(
        &self,
        Parameters(params): Parameters<DnsLookupParams>,
    ) -> Result<CallToolResult, McpError> {
        let result = ToolboxService::dns_lookup(
            &params.domain,
            &params.record_type,
            params.nameserver.as_deref(),
        )
        .await
        .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// Perform WHOIS lookup.
    #[tool(description = "Query WHOIS information for a domain (registrar, registration dates, name servers)")]
    async fn whois_lookup(
        &self,
        Parameters(params): Parameters<WhoisLookupParams>,
    ) -> Result<CallToolResult, McpError> {
        let result = ToolboxService::whois_lookup(&params.domain)
            .await
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// Perform IP geolocation lookup.
    #[tool(description = "Look up geolocation data for an IP address or domain (country, region, city, ISP, ASN)")]
    async fn ip_lookup(
        &self,
        Parameters(params): Parameters<IpLookupParams>,
    ) -> Result<CallToolResult, McpError> {
        let result = ToolboxService::ip_lookup(&params.query)
            .await
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// Check DNS propagation.
    #[tool(description = "Check DNS record propagation across 13 global DNS servers")]
    async fn dns_propagation_check(
        &self,
        Parameters(params): Parameters<DnsPropagationCheckParams>,
    ) -> Result<CallToolResult, McpError> {
        let result = ToolboxService::dns_propagation_check(&params.domain, &params.record_type)
            .await
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }

    /// Check DNSSEC status.
    #[tool(description = "Validate DNSSEC deployment for a domain (DNSKEY, DS, RRSIG records)")]
    async fn dnssec_check(
        &self,
        Parameters(params): Parameters<DnssecCheckParams>,
    ) -> Result<CallToolResult, McpError> {
        let result = ToolboxService::dnssec_check(&params.domain, params.nameserver.as_deref())
            .await
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        let json = serde_json::to_string_pretty(&result)
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        Ok(CallToolResult::success(vec![Content::text(json)]))
    }
}

#[tool_handler]
impl ServerHandler for DnsOrchestratorMcp {
    fn get_info(&self) -> ServerInfo {
        ServerInfo {
            protocol_version: ProtocolVersion::LATEST,
            capabilities: ServerCapabilities::builder().enable_tools().build(),
            server_info: Implementation::from_build_env(),
            instructions: Some(
                "DNS Orchestrator MCP Server - Manage DNS records across multiple providers \
                 (Cloudflare, Aliyun, DNSPod, Huaweicloud). \
                 Use list_accounts to see available accounts, list_domains to see domains, \
                 and list_records to view DNS records. \
                 Toolbox tools (dns_lookup, whois_lookup, ip_lookup, dns_propagation_check, dnssec_check) \
                 work without any account configuration."
                    .into(),
            ),
        }
    }
}
